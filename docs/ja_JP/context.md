# CTONコンテキスト

[docs](../).[ja_JP](./README.md).[CTON coreAPI](./coreAPI.md).CTONコンテキスト

CTONコンテキストはCTONメモリ管理のユニットで、
複数のスレッドで並行して実行しても、
問題が生じないように設計した最小のユニットである。

複数のスレッドで同じコンテキスト、
または同じコンテキストから作ったオブジェクトを操作するには、
排他制御は常に必要である。
それに対して、同じコンテキストではない限り、
排他制御が無くてもスレッドセーフが保証される。

CTONコンテキスト自身を含んで、CTONが使うすべてのメモリは、
指定されたメモリフークによって確保される。
このメモリフークはあるメモリプールを指定することが可能である。
そしてメモリプールをリリースすることで、
このメモリフークを使ってるすべてのCTONコンテキストが解放され、
それらのコンテキストから作ったオブジェクトも解放される。
この点は長生きのネットワークサーバなどに対して有利である。

## cton_init

- CTONコンテキストを作成する。

### 書式

`cton_ctx *cton_init(cton_memhook *hook);`

### 説明

`cton_init()`はCTONコンテキストを作成して、
`hook`で指定されたメモリフークで初期化する。
`hook`が`NULL`ならば、
このライブラリによってが提供されたメモリフークがこの代わりに使われる。

指定されたメモリフークには、
少なくとも`palloc`フークが有効であることが望まれる。
`palloc`さえ定義されない場合は、無効なフークと判定され、`NULL`を返す。
また、コンテキストに使うメモリもこのメモリフークによって確保される。
そしてコンテキストに使うメモリが確保できない場合も、失敗と判定して`NULL`を返す。

### 返り値

`cton_init()`は成功すれば、
作成したCTONコンテキストハンドルを返す。
指定されたメモリフークが無効である場合や、
メモリ確保失敗した時には、`NULL`を返す。


## cton_destory

`cton_destory(cton_ctx *ctx);`

- CTONコンテキストを回収する。

この関数はCTONコンテキストを回収する。このコンテキストから確保したすべてのメモリも回収される。もしメモリフークのなかで`destroy`関数が有効であれば、その関数が呼び出され、メモリプールがリリースされることを望まれる。