# CTONコンテキスト

[docs](../).[ja_JP](./README.md).[CTON coreAPI](./coreAPI.md).CTONコンテキスト

CTONコンテキストはCTONメモリ管理のユニットで、
複数のスレッドで並行して実行しても、
問題が生じないように設計した最小のユニットである。

複数のスレッドで同じコンテキスト、
または同じコンテキストから作ったオブジェクトを操作するには、
排他制御は常に必要である。
それに対して、同じコンテキストではない限り、
排他制御が無くてもスレッドセーフが保証される。

CTONコンテキスト自身を含んで、CTONが使うすべてのメモリは、
指定されたメモリフークによって確保される。
このメモリフークはあるメモリプールを指定することが可能である。
そしてメモリプールをリリースすることで、
このメモリフークを使ってるすべてのCTONコンテキストが解放され、
それらのコンテキストから作ったオブジェクトも解放される。
この点は長生きのネットワークサーバなどに対して有利である。

## cton_init

- CTONコンテキストを作成する。

### 書式

`cton_ctx *cton_init(cton_memhook *hook);`

### 説明

`cton_init()`はCTONコンテキストを作成して、
`hook`で指定されたメモリフークで初期化する。
`hook`が`NULL`ならば、
このライブラリによってが提供されたメモリフークがこの代わりに使われる。

指定されたメモリフークには、
少なくとも`palloc`フークが有効であることが望まれる。
`palloc`さえ定義されない場合は、無効なフークと判定され、`NULL`を返す。
また、コンテキストに使うメモリもこのメモリフークによって確保される。
そしてコンテキストに使うメモリが確保できない場合も、失敗と判定して`NULL`を返す。

### 返り値

`cton_init()`は成功すれば、
作成したCTONコンテキストハンドルを返す。
指定されたメモリフークが無効である場合や、
メモリ確保失敗した時には、`NULL`を返す。


## cton_destory

- CTONコンテキストを削除する。

### 書式

`cton_destory(cton_ctx *ctx);`

### 説明

この関数はCTONコンテキストを削除する。
このコンテキストから確保したすべてのメモリも回収する。

メモリフークの`pdestroy`関数が有効であれば、
その関数が呼び出され、
メモリプールがリリースされることで全てのメモリを回収する。
なければ、コンテキスト自身が持つオブジェクトリストで、
すべてのオブジェクトを解放する。
もし`pfree`関数も無効であれば、
この関数は何もしなくて終わる。

### 課題

1. この関数はまだ実装してなかった。
2. いまのハッシュ実装は、赤黒木の構造体は解放されない。これはバグだと考える。

## cton_seterr

## cton_geterr

## cton_strerr

## cton\_err\_clear