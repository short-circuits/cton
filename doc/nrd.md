# NRD - Yeonji's Non Relational Data Manage Library

_aka Untitled Object Library_

本来想叫「Yeonji's Awesome Object Integrate」的，但是那样岂不就变成YAOI了（笑笑笑

## 简介

这是Yeonji**自用**的一个简陋的数据类型封装。_（说了是自用了，拒绝添加功能或者修bug的issue。微笑m微笑m微笑p微笑）_

Yeonji是一个「浮気しない」的C语言用户，但是偶尔也会厌烦于反复编写几种基础的C语言数据结构。
作为一个忠实的用户，当然不会就此放弃。于是Yeonji决定编写一个自用的数据结构封装。

这个库的主要目的是对于基本类型，和对应数据类型的常见算法的封装。
同时Yeonji还准备把这个库用作自己的通用对象管理程序，这样即使在C语言中也可以像各种脚本语言那样便利地操作各种对象。

各种对象的存储方式及应用的算法，请查看对应对象的文档。
为表述方便，本文档同时使用**“NRD对象”**来表示**非关系数据对象**。
在不引起混淆的情况下，亦可直接简称**对象**。

### 对象类型

0. [空对象](./null.md)（即NULL）
1. [布尔值](./boolean.md)（真假）
2. [单字节整数](./numeric.md)（8比特有符号整数）
3. [双字节整数](./numeric.md)（16比特有符号整数）
4. [整数](./numeric.md)（32比特有符号整数）
5. [长整数](./numeric.md)（64比特有符号整数）
6. [单精度浮动小数点数](./float.md)（32位浮点数）
7. [双精度浮动小数点数](./float.md)（64位浮点数）
8. [多重精度](./mp.md)（受存储空间限制）
9. [字符串](./string.md)（存放合法字符的二进制阵列）
10. [二进制阵列](./string.md)（应用程序接口层次等同于字符串）
10. [阵列](./array.md)（对象数组）
11. [散列](./hash.md)（键值对）

后文会一并描述“NRD对象”统一提供的应用程序接口，与对象的实现方法。
各对象的特有的应用程序接口与实现方法请点击查看对应文档。

### 转储选项

对象可以直接转换为以下几种格式：

0. 二进制命名标签（游戏「我的世界」用于向文件中存储数据的一种存储格式）
1. 爪哇脚本语言对象表记（俗称JSON，会丢失部分信息）
65535. 非关系数据二进制对象转储
65536. 非关系数据纯文本对象表记

符合一定条件的对象可以直接转换为以下格式：

1. 初始化设定文件（即INI文件）
2. 资源交换文件格式（即RIFF文件，包括WAV和AVI格式）
3. 设备无关位图（即DIB文件，包含BMP格式）
4. 标签图像文件格式（即TIFF）

同时以上格式均可以转换为非关系数据对象。

## 应用程序接口

_本节内容仅介绍所有对象通用的应用程序接口。各类对象特有应用程序接口请参考各自对象的部分。_

### 预定义类型

`nrd_t` 非关系数据对象

`NRD_NULL` 非关系数据对象 空对象类型标识
`NRD_BOOL` 非关系数据对象 布尔对象类型标识

### 公共操作函数

`nrd_t nrd_new(int type)`

新建一个非关系数据对象。
传入参数`type`为新对象的类型标识。

_通过此方式创建的字符串、阵列等对象不会为其分配存储空间。如果希望创建包含存储空间的对象，请使用以下操作_

> `nrd_t nrd_null_new(void)` `nrd_t nrd_bool_new(int val)` `nrd_t nrd_new_int8(void)` `nrd_t nrd_new_int16(void)` `nrd_t nrd_new_int32(void)` `nrd_t nrd_new_int64(void)` `nrd_t nrd_new_float32(void)` `nrd_t nrd_new_float64(void)` `nrd_t nrd_new_mp(void)` `nrd_t nrd_new_str(void)` `nrd_t nrd_new_float64(void)` `nrd_t nrd_new_str(const char * str, size_t len)` `nrd_t nrd_new_bin(void)` `nrd_t nrd_new_arr(void)` `nrd_t nrd_new_hash(void)`

`void nrd_del(nrd_t obj)`

删除一个非关系对象。
其传入参数应为一个合法的NRD对象。
当传入一个非法的对象时，其行为是未定义的。

`int nrd_type(nrd_t obj)`

查询一个非关系对象的类型。
其传入参数应为一个合法的NRD对象，并将返回这个对象的类型标识。
当传入一个非法的对象时，其行为是未定义的。

### 私有操作函数

`nrd_t nrd_quote(nrd_t obj)`

为对象创建一个引用。

## 内部实现

本章节主要介绍非关系数据对象库内部的实现。
这部分文档主要解释了与代码无关的设计（流程，思想等）。
与具体代码相关详细解说请参阅代码内部注释。

### “NRD对象”数据结构实现

“NRD对象”类型（`nrd_t`）被定义为一个指向对应对象类型结构体的指针。
因不同对象使用的结构体各不相同，此“NRD对象”类型应被定义为一个通用指针（即`void *`或`unsigned long`）。

所有类型的“NRD对象”结构体，应保证最初若干字节构成相同。
这部分相同的构成，已被预定义为一个“NRD对象”头结构体（`struct nrd_header_s`）。
声明“NRD对象”结构体时，只需引用这一头结构即可。
根据设计，公共应用程序接口不会按照特定对象结构体来操作对象。
因此各自对象结构体引用此头结构时使用的名称不限。
但出于形式统一的考虑，请使用`nrd_header`。

创建“NRD对象”同时设置对象的类型，对象在创建后无法更改其类型。
判断对象的类型时，将“NRD对象”类型转换为对象头结构体指针，
并通过其中表示类型的元素（`-> type`）进行类型判断。

对于需要额外数据的对象，内部使用一个数据指针来保存实际的数据的存储空间。
这一指针不应当被用户或错误的类型的应用程序接口来操作。
强行使用错误类型的应用程序接口操作数据指针的后果是不可预料的。

### “NRD对象”的内存管理

创建“NRD对象”时需要向系统申请存储空间，若空间申请失败，则返回空指针（`NULL`）。
“NRD对象”被成功创建后，其地址在对象生命周期内不会发生改变。
但“NRD对象”内的数据指针扔可能会随着使用重新分配。
因此请勿缓存“NRD对象”内的数据指针，遵照应用程序接口调用。

对于需要包含额外数据空间的类型（字符串，阵列，散列等），对象结构体中仅保存一个数据指针。
数据指针指向根据实际使用需要分配的存储空间。
当不包含任何数据时，这个指针可被设置为空指针（`NULL`）。
程序使用者在操作这个地址时，需要注意对数据指针为空指针这一情况进行处理。

“NRD对象”库允许使用一个用户自定义的存储空间管理函数。
这一操作是通过“NRD对象”存储空间管理钩子来实现的。
存储空间管理钩子（`nrd_mhook_t`）被定义为一个指向一个存储空间管理函数结构体的指针。
详细应用参见**[存储空间管理钩子](./memory_manage.md)**。

“NRD对象”使用一个类似引用计数的机制来进行内存管理。
存在**创建**，**引用**，**删除**这三种可以对引用计数进行修改的操作。

### “NRD对象”的创建

应用程序接口提供了以下方式来创建一个新的“NRD对象”。

第一种方式是新建“NRD对象”调用（`nrd_new()`）。
这一调用需要提供两个参数。
第一个参数是需要创建的对象类型，第二个参数为存储空间管理钩子
（使用系统默认存储空间管理程序时，可传入空指针）
通过这一方式创建的对象，不会为其分配额外数据存储空间（即数据指针为空指针）。

另一种方式是通过新建某一类型的“NRD对象”调用（`nrd_str_new()`，`nrd_arr_new()`等）。
这一方式无需提供需创建的对象类型。但仍需传入存储空间管理钩子。
通过这一方式创建的对象，会根据需要为其分配数据存储空间。
在实现中，新建“NRD对象”调用间接引用了此调用，并传递了内容为空的参数。

对于布尔值对象，整数，浮动小数点数等数据类型，因为数据被直接保存于对象结构体中，不会分配额外的存储空间。
对于空对象，因为不存在可能改变的数据值，使用同一个全局对象。

在创建对象后，对象的引用计数被设置为`1`。

### “NRD对象”的引用与删除

引用是一个为内存管理提供的操作。
用户没有直接调用这个操作的理由。

对于数组，散列等，允许包含“NRD对象”作为成员的结构，在插入一个新对象时会自动将引用自增一。
同时在使用任意方式查找一个对象时，对象的引用自增一。
除此之外，用户无需自行进行引用操作。

删除“NRD对象”的行为会因引用计数的不同而有所不同。

程序会首先对引用计数进行自减一操作。
若此操作后引用计数仍大于一，则不进行下一步操作。

当引用计数小于归零时，说明对象可以被安全的释放（不考虑用户不遵守调用约定带来的意外）。
对于存在子对象的对象，首先递归释放子对象。
在完成所有子对象的释放后释放此对象。

引用计数是为了确保对象可以在合适的时候被释放的一个妥协操作。
为了避免查找对象后，是否可以安全的删除这个对象这样的问题而诞生。

这也就要求创建/查找对象操作和删除对象操作应当成对出现。
